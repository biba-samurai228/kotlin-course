---
sidebar_position: 7
id: scope_visibility
---
# Области видимости
Теперь перейдём к довольно интересной, но немножко сложной теме — области видимости.
Ранее мы рассматривали переменные и функции, так что теперь стоит рассмотреть случаи, когда функция или переменная может быть недоступна или наоборот доступна в некоторых местах.
**Область видимости** (англ. scope) в **программировании** — важная концепция, определяющая доступность переменных, функций и других сущностей. Данная концепция разделяет переменные, функции и пр. на глобальные и локальные.
Давайте рассмотрим на примере:
```kotlin
fun foo() {
	val a = 1
}
fun main() {
	println(a + 1)
}
```
Данный код выведет следующую ошибку:
```kotlin
Unresolved reference: a
```
Что означает, что переменная созданная в функции `foo()` недоступна в функции `main()`.
Почему? В этом конкретном случае, `a` переменной не может существовать и в теории, так как она создаётся при вызове функции `foo`, а она у нас не вызывается.
А что если мы её вызовём?
```kotlin
fun foo() {
	val a = 1
}
fun main() {
	foo()
	println(a + 1)
}
```
Теперь она создана и, по-идее, программа должна работать, но как бы не так, мы получим всё ту же ошибку:
```kotlin
Unresolved reference: a
```
Дело в том, переменные видны только в месте создания и ниже по иерархии.
Ниже по иерархии? Давайте, перепишем наш код так чтобы переменная была видна:
```kotlin
var a = 0
fun foo() {
	a = 1
}
fun main() {
	foo()
	println(a + 1)
}
```
Для наглядности изменим переменную при вызове `foo()`.
Подобное и означает «ниже по иерархии».
Функция, что использует переменную `a` наследует область видимости (aka scope) файла, в котором мы её создали.
И так работает с любым местом, где переменную создают. Даже в функции:
```kotlin
var c = 2
fun foo() {
	var a = 2 // создаём переменную на уровне функции.
	c = 4 // переменная на уровне файла видна в функции `foo`
	fun bar() {
		val b = a.pow(2) // переменная `a` видна в функции `bar` из-за наследования области видимости
		a = b
	}
	bar() // функция доступна в месте её создания (декларирования)
	println(a) // переменная доступна в месте её создания
}
```
Да, да, в котлине можно даже создавать функции в функциях, не удивляйтесь! Хотя сейчас не об этом.
В этом случае, функция `bar` наследует область видимости файла, функции `foo` и так может продолжаться до бесконечности. Вообще, фигурные скобки `{}` можно рассматривать как оператор, который создаёт новую область видимости.
Давайте визуализируем то, как строится наша область видимости:
![scope](images/scope_visualization_1.excalidraw.svg)
Т.е: каждая новая область видимости наследует «родителя», в котором она создаётся.
Родитель и всё, что выше по иерархии, не видит что-то созданное ниже по иерархии.
P.S: Вообще подобные переменные, что создаются в функциях, называют — **локальной переменной**.
А переменная, которую мы создавали вне функции — **глобальной**. Она видна везде, начиная с того же файла, заканчивая другими.
Заканчивая другими? Так же, как мы создавали котлин-файл под именем «Main», мы можем создать любой другой файл. Как минимум, для того чтобы не держать весь код в одном файле. Это упростит навигацию по коду в проектах немножко сложнее тех, которые мы делали ранее.
А что будет если создать ещё один файл, в котором мы создадим такие функции и переменные? Что ж, давайте проверим:
```kotlin
// File: another.kt
val abc = 999_999_999
fun someFunction() {
	println("someFunction()")
}
```
Перейдя в файл «Main» и попробовав вызвать эти функции нас ждёт успех:
```kotlin
var c = 2
fun foo() {
	var a = 2
	c = 4
	fun bar() {
		val b = a.pow(2)
		a = b
	}
	bar() 
	someFunction() // вызываем функцию с файла `another.kt`
	println(a + abc) // получаем переменную с файла `another.kt`
}
```
Что же это значит? А это значит то, что у файла так же, как и например у функции, есть дочерний scope (область видимости) и это некоторые другие файлы.
Некоторые другие файлы? Не все?
Дело в том, что файлы идентифицируются не только по их названию, но и по их **пакету**.
Пакет? Логически будет предположить, что никто не имел ввиду полиэтиленовый или какой либо другой пакет, а какой-то уникальный идентификатор.
Что за уникальный идентификатор и зачем он?
Всё для того же, для чего и создаются другие файлы: для удобства. Нужно же разделять и сортировать написанный код.
Из реальных примеров, вы можете взять системные папки по-типу Music, Videos, Images и прочие, что содержат информацию только определённой категории.
В Котлине подобная же система категоризации кода, единственное, что отличается, — это термин (**пакет**).
Собственно, так же как и с системными папками, мы можем делать структуру нашего проекта разделяя на какие-то осмысленные части.
Например, для всяких математический вычислений мы можем создать такой пакет:
`math.calculations`.
В файловой структуре мы просто создаём соответствующие частям пакета (разделены точкой) папки:
Т.е папку `math`, а в ней ещё одну папку `calculations`. После чего, можно уже создавать наши файлы с кодом.
Для примера создадим файл с функцией, которая будет решать следующее уравнение:

$$
f(x) =\left\{
\begin{array}{ c l }
2x^2 & \quad \textrm{если } x < 0
\\
x & \quad \textrm{если } x \geq 1   
\le 50
\\
(x \cdot 2)^2 & \quad \textrm{если } x > 50 < 200
\\
1                 & \quad \textrm{в ином случае}
\end{array}
\right.
$$

```kotlin
// файл Function.kt
package math.calculations // автоматически добавилось нашей IDE (идентификатор нашего файла)
fun f(x: Double): Double {
	return when {
		x < 0 -> 2 * x.pow(2)
		x >= 1 <= 50 -> x
		x > 50 < 200 -> (x * 2).pow(2)
		else -> 1
	}
}
```
Как вы уже заметили, сверху у нас добавилась строка кода с местом нашего файла.
Он обязателен, даже если вы поместили его в соответствующую папку. Это потому, что Kotlin допускает указание пакета свободно (т.е, вы можете не создавать файловую структуру, что будет соответствовать пакету).
Это делается в несложных проектах, где 8-10 файлов и проблем с навигацией нет, но я вам рекомендую всегда создавать соответствующую файловую структуру.
Что ж, перейдём к вызову нашей функции:
```kotlin
// файл Main.kt
fun main() {
	println(f(1.0))
}
```
По-идее так, но вызвав мы получим следующую ошибку:
```kotlin
Unresolved reference: foo
```
Дело в том, что по-умолчанию, область видимости ограничивается текущим пакетом (в нашем случае хоть он и отсутствует, но он всё такой же идентификатор, даже если он и пустой).
Для того чтобы получить что-то из другой области видимости (aka пакета) нужно для начала «импортировать» идентификатор.
«Импорт» делают с помощью ключевого слова `import`. Он всегда должен указываться сверху, сразу после пакета (ну или при его отсутствии, просто сверху).
Схема импорта такая:
```kotlin
import [пакет].[идентификатор]
```
Т.е, чтобы вызвать функцию `f(x: Double)`, нам нужно сделать следующее:
```kotlin
// файл Main.kt
import math.calculations.f
fun main() {
	println(f(1.0))
}
```
И у нас всё запуститься успешно!
Но, если без импортирования идентификаторы других пакетов не видны, то можно создавать дубликаты названий?
**Да**, вы можете создавать дубликаты имён за исключением ситуаций, когда вы пытаетесь создать одинаковый идентификатор в одном конкретном скоупе (области видимости).
Т.е, следующее запрещено:
```kotlin
fun main() {
	val a = 1 // Conflicting declarations: val a: Int, val a: Int
	println(a)
	val a = 2 // Conflicting declarations: val a: Int, val a: Int
	println()
}
```
Однако, разрешено следующее:
```kotlin
val a = 1
fun main() {
	println(a)
	val a = 2
	println(a)
}
```
Дело в том, что приоритетным пространством имён (с нашими идентификаторами) является текущая область видимости (aka скоуп).
Это всё потому, что как таковая функция (или любое другое место) — новый независимый скоуп (область видимости). Мы не можем быть уверены, что рано или поздно мы не импортируем какую-то переменную или же не объявим такую же в этом файле. А выдумывать бесконечно новые имена не сделает код проще, а только усложнит его.
Кстати, стоит отметить, что создания дубликатов в одном пакете — невозможны.
Дело в том, что со стороны котлина файл не независимая структурная единица и она существует только в исходном коде.
Вспомните пример с функцией в пакете `math.calculations`, мы же не указываем конкретный файл при вызове функции или её импорте? Потому дубликаты в одном пакете и невозможны, так как определить конкретный идентификатор с конкретного файла невозможно.
Что ж, для закрепления, давайте визуализируем всё то, что мы обговорили выше:
![usage](images/scope_visualization_2.excalidraw.svg)
У нас есть проект с двумя уникальными пакетами: `math.calculations` и родительским (ну или пустым). Файл «Main» завязан на функцию `f(x: Double)` в пакете `math.calculations` (мы это выделили линией для визуализации).
Что ж, подведём промежуточный итог:
- Программа делится на разные области видимости (скоупы), которые имеют четкую иерархию в зависимости от того, где и что вы создаёте.
- Иерархия обычно следующая: область видимости на уровне пакета -> область видимости на уровне декларации (функции, например) -> и так далее (например вложенные функции).
- Родительской областью видимости является пакет, в котором существует наш идентификатор (функция, переменная). Идентификаторы с других пакетов не видны по-умолчанию.
- При необходимости, можно расширить пространство имён (идентификаторы, что видны в другой области видимости) с помощью импорта (`import [пакет].[идентификатор]`).
### Модификаторы видимости
Кстати, говоря о том, что файл — это не независимая структура, я немножко соврал и сейчас объясню почему.
Давайте решим следующий пример:
$$
f(x) =\left\{
\begin{array}{ c l }
x^2 & \quad \textrm{если } x < 0
\\
a(x)                 & \quad \textrm{в ином случае}
\end{array}
\right.
$$
Функция $a(x)$ у нас такая:
$$
f(x) =\left\{
\begin{array}{ c l }   
2x & \quad \textrm{если } x > 0 < 200
\\
1                 & \quad \textrm{в ином случае}
\end{array}
\right.
$$
На Kotlin нам нужно написать следующее (в файле math.calculations.Function):
```kotlin
fun f(x: Double): Double {
	return if(x < 0) x.pow(2) else a(x)
}
fun a(x: Double): Double {
	return if(x > 0 < 200) 2 * x else 1
}
```
И теперь вызовём это в Main:
```kotlin
fun main() {
	val input: Double = readln().toDouble()
	println(f(input))
}
```
И на этом наша программа, условно, закончена.
Посмотрев на функцию `a(x: Double)` мы можем подумать о том, что она используется только в функции `f(x: Double)` и в принципе, она нигде кроме в файле 'Function.kt' не нужна.
Можно эту функцию просто игнорировать в подсказках и не импортировать, однако, если таких функций много? Это очевидно, захламляет глобальное пространство имён, даже если оно не импортировано.
На выручку к нам приходят модификаторы видимости! **Модификаторы видимости** — ключевые слова, что описывают то, где виден идентификатор.
Для нашего случая, существует модификатор `private`. Он указывает, что переменная видна только там, где её создали и ниже по иерархии.
На самом деле, формула создания той же функции выглядит так:
```kotlin
[visibility-modifier] fun [названиеФункции](параметр: Тип): Тип {...}
```
По-умолчанию, ко всем декларациям (функциям, переменным и прочему) неявно применяется модификатор `public` (т.е публичный, видимый изнутри).
`fun main()` -> `public fun main()`.
В нашем же случае, мы делаем следующее:
```kotlin
private fun a(x: Double): Double {
	return if(x > 0 < 200) 2 * x else 1
}
```
Кстати, в этом случае, при указании одинаковых идентификаторов в одном пакете, но разных файлах допускается, так как конфликт попросту невозможен.
С переменной будет так же:
```kotlin
private val a: Int = 0
```
#### Вывод
Изначальное рассмотрение уникальности имён, создание переменных и функций оказалось не таким простым, как вы поняли.
Как я уже упоминал ранее, идентификатор функции строится на следующих его свойствах — это имя и параметры.
С учетом рассмотренных тем: *область видимости* и *модификаторов видимости*, мы их так же добавляем в уникальность идентификатора (обычно это называют сигнатурой).
Ну и тоже самое мы делаем с переменной.
Итоговым вариантом идентификаторов у нас будут:
- Функция — модификатор видимости + область видимости + имя + набор параметров (различие в их количестве или типе).
- Переменная — модификатор видимости + область видимости + имя.

Желательно самому поиграться с этим для большего понимания!
