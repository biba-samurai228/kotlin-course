---
sidebar_position: 8
id: cycles
---
# Циклы и Рекурсии
Теперь же, перейдём к так же довольно интересной, но немножко непростой теме — циклы.
Чтобы больше понять, что такое циклы давайте создадим какую-то задачу. Например, возьмём задачу, которую мы решали в прошлой теме. Для того, чтобы решить уравнение с использованием ввода, мы каждый раз запускаем нашу программу. А что, если сделать в нашей программе бесконечный ввод чтобы каждый раз не перезапускать нашу программу?

Вообще, без нашей темы циклов, это вполне можно было решить следующим образом:
```kotlin
fun main() {
	printlt("Введите число:")
	val input: Double = readln().toDouble()
	println("Результат: " + input.toString())
	return main() // в конце функции просто вызываем её ещё раз
}
```
И вот, решение найдено!

Подобное называют **рекурсией**. Простыми словами — это понятие объявления (написания, описания) кода функции через саму себя. Это как матрёшка, но, которая в нашем случае не имеет конца.

Что ж, а как теперь завершить нашу программу? Можно конечно это сделать закрыть принудительно процесс программы через инструменты системы или IDE, но давайте будем людьми и сделаем какой-то механизм выхода.

Чтобы сильно не заморачиваться, давайте введём условие, что для выхода из программы нам нужно написать «:q».
```kotlin
fun main() {
	printlt("Введите число (или воспользуйтесь :q для выхода):")
	val input: String = readln() // создаём переменную с текстом так как нам нужно проверять ввод пользователя
	if(input != ":q") {
		val input: Double = input.toDouble() // сила областей видимости!
		println("Результат: " + f(input).toString())
		main()
	}
}
```

Это всё так же останётся рекурсией, только уже не бесконечной (у нас появилось условие).

Что ж, рассмотрев довольно простой пример рекурсии, к которому можно было прийти самому при попытке решить задачу с перезапуском нашего решения уравнений.

Что же тогда такое циклы? **Циклы** — это средства языка, которые воссоздают рекурсию. Их так же относят к операторам, называя *циклическими* операторами.

Так что, теперь, давайте рассмотрим как это можно решить другими средствами языка. Не всегда же вы будете создавать отдельно функции для 'повторения чего-то', да?

### While
Для облегчения вам жизни придумали довольно полезную конструкцию — `while`.
Записывается следующим образом:
```kotlin
while(boolean) {
	// тут действие, что повторяется
}
```

Подобная конструкция выполняет своё содержимое в `{}`, но перед каждым выполнением смотрит в условие (aka boolean-выражение) и если там `true`, то содержание выполняется, а если `false` — нет.

Наш предыдущий код можно выразить через `while` следующим образом:
```kotlin
fun main() {
	var shouldRun: Boolean = true
	while(shouldRun) {
		printlt("Введите число (или воспользуйтесь :q для выхода):")
		val input: String = readln()
		if(input == ":q") {
			shouldRun = false // при следующем выполнении цикл увидит, что в условии `false`
		} else {
			val input: Double = input.toDouble()
			println("Результат: " + f(input).toString())
		}
	}
}
```
Вот и наш первый цикл! Но, какой-то он сложный, вам не кажется?
Всё это можно упростить воспользовавшись специальными дополнительными операторами: `break` и `continue`.

Что делают эти два оператора? Давайте разберёмся.
- `break` (можно перевести как разорвать, оборвать) — принудительно заканчивает цикл. Т.е даже если условие будет `true` цикл всё равно закончится.
- `continue` (переводится как продолжить) — заканчивает выполнение текущего *повторения*. В отличии от `break`, `continue`, грубо говоря, выходит из кода (код после него не выполняется) и переходит сразу к следующему повторению (к проверке условия и дальнейшего повторения в случае, если там `true`).

Давайте перепишем наш код:
```kotlin
fun main() {
	while(true) { // можно забить на условие
		printlt("Введите число (или воспользуйтесь :q для выхода):")
		val input: String = readln()
		if(input == ":q") {
			break // выходим из цикла
		} else {
			val input: Double = input.toDouble()
			println("Результат: " + f(input).toString())
			continue // вообще, он необязателен в нашем случае, но для наглядности добавим
			println("А меня не будет!") // IDE нам подскажет, что к этому участку кода мы никогда не дойдём из-за continue
		}
	}
}
```

Из-за ненадобности мы выкидывает переменную `shouldRun`, так как есть куда удобней способ с `break`.
#### Do-while
Одним из подвидов цикла while является `do-while`. Кроме названия, он отличается тем, что в **do while** сначала выполняется тело цикла, а затем проверяется условие продолжения цикла. Из-за такой особенности **do while** называют циклом с *постусловием*. В свою же очередь, обычный **while** называют циклом с *предусловием*.

Записывается следующим образом:
```kotlin
do {
	// actions
} while(bool)
```

В подобном цикле так же существует `break` и `continue`, которые никак не отличаются.
Однако, нашу задачу можно решить через **do-while** и без них следующим образом:
```kotlin
// создадим переменную с сообщением чтобы потом её переиспользовать
val numberInputMessage = "Введите число (или :q для выхода):"

// создадим отдельную функцию для удобства
private fun requestInput(message: String): String {
	println(message)
	return readln()
}

fun main() {
	var input = requestInput(numberInputMessage)
	do {
		println("Результат: " + f(input.toDouble()).toString())
		input = requestInput(numberInputMessage) // записываем следующий ввод чтобы проверить после повторения, что было введено
	} while(input != ":q") // если ввод не ":q" программа будет продолжать работать
}
```
Мы создали для удобства функцию и переменную, что объединяла похожий код. Так же сделали переменную вне цикла и запись в неё в конце цикла (для того чтобы проверять после повторения ввод пользователя).

Это альтернативное решение, хоть и не совсем хорошее.
### For
И теперь перейдём к не менее важному виду циклов — `for`.
Отличие этого вида циклов в том, что он не строится на условии, а на итераторе.
Что такое итератор? Итератор — это встроенная утилита в язык, которая перемещается между какой-то суммой элементов. Т.е каждое *повторение* будет соответствовать одному элементу в этой сумме.
В нашем случае, эта сумма элементов будет соответствовать диапазону, а элемент — единице исчисления этого диапазона.

Что такое диапазон? Простыми словами — интервал значений какой-либо величины. Примером диапазона может быть [0; 5] (описывает интервал чисел от 0 до 5, включительно).
Бывают разные виды диапазонов, но пока мы рассмотрим самый простой вариант с диапазоном целых чисел.

Как создать подобный цикл? Для начала рассмотрим прогрессию с целыми числами:
```kotlin
for(i in 0..5) {
	println(i)
}
```

Тут мы лицезреем оператор `in`, который работает с итератором (в нашем случае, с тем, что его выражает — диапазоном).

Данный код выведет следующее:
```
0
1
2
3
4
5
```

Довольно очевидно работает, не так ли?

Давайте решим следующую задачу:
> Воссоздайте функцию степеня для положительных чисел.
> Эквивалентно функции Int.pow(x: Double).
```kotlin
fun pow(number: Int, times: Int): Int {
	var output = number // создаём переменную, где будет хранится умноженное значение
	for(i in 0..times) { // через диапазон указываем, сколько раз повториться
		output *= number // умножаем то, что уже есть на параметр number
	}
	return output // возвращаем число в степени
}
```
Тут нам IDE подскажет, что идентификатор `i` не используется и его желательно заменить на `_`. Дело в том, что в котлине по код-стилю принято, что идентификаторы, что не используются называют именно так.

Что же относительно задачи, тут несложный императивный вариант решения.

Давайте решим ещё одну задачу:
> Напишите программу, где пользователь вводит **любое целое положительное число.** А программа суммирует все числа от 1 до введенного пользователем числа.
> Т.е, если введут число 4, мы должны суммировать следующие числа: 1 + 2 + 3 + 4.

В этом нам как раз очень помогут диапазоны!
```kotlin
fun sum(input: Int): Int {
	var output: Int = 0 // создаём всё так же временную переменную, к которой будем добавлять результат цикла.

	for(i in 1..input)
		output += i // можно убрать `{}` так как одна последовательность действий

	return output
}
```
Мы создали всё так же временную переменную и всё так же использовали диапазоны с переменной `i`, что содержит элемент интервала этого диапазона на каждую итерацию (повторение) цикла (который и соответствует тому, что мы по-сути и делаем).

И на последок, решим ещё одну задачу:
>  Даны натуральные числа от 1 до 50. Найти сумму тех из них, которые делятся на 5 или на 7.

Перед решением данной задачи, вспомним один из арифметических операторов — `%` (остаток от деления).
```kotlin
fun main() {
	println(22 % 4)
	println(4 % 2)
}
```

Выведет `2` и `0`, так как будет такой остаток после деления (в первом не делится нацело, во втором — делится).

Наша задача состоит в том, чтобы найти числа, что делятся нацело на 5 и 7.
Это будет эквивалентно следующему:
```kotlin
number % 5 == 0 || number % 7 == 0 
```
Это условие будет нам подходить. Теперь же, остаётся только сделать цикл, временнную переменную в которую мы будем добавлять результат.
```kotlin
fun main() {
	var temp: Int = 0
	for(i in 1..50)
		if(i % 5 == 0 || i % 7 == 0)
			temp += i
	println("Сумма: " + temp)
}
```

Ответом у нас должно получится: `436`.
